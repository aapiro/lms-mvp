#!/usr/bin/env bash
set -euo pipefail

# scripts/transcode-and-upload.sh
# Descarga una lección desde /api/lessons/{id}, transcodifica a MP4 (H.264/AAC), sube a MinIO y actualiza la fila en Postgres.
# Requiere Docker en el host. No requiere ffmpeg ni mc instalados localmente.

# Uso:
# ./scripts/transcode-and-upload.sh <lessonId> [outputFileName]
# Ejemplo:
# ./scripts/transcode-and-upload.sh 22 lesson-22.mp4

LESSON_ID=${1:-}
OUT_NAME=${2:-}

if [ -z "$LESSON_ID" ]; then
  echo "Usage: $0 <lessonId> [outputFileName]"
  exit 1
fi

# Defaults
OUT_NAME=${OUT_NAME:-lesson-${LESSON_ID}.mp4}
TMP_DIR=$(mktemp -d)
ORIG_PATH="$TMP_DIR/orig"
OUT_PATH="$TMP_DIR/$OUT_NAME"

# Config (coincide con docker-compose.yml del proyecto)
MINIO_HOST_INTERNAL="minio:9000"
MINIO_ALIAS="local"
MINIO_USER="minioadmin"
MINIO_PASS="minioadmin123"
MINIO_BUCKET="lms-content"
# Network name generated by docker compose: use the project network name
DOCKER_NETWORK=${DOCKER_NETWORK:-lms-mvp_lms-network}
POSTGRES_CONTAINER="lms-postgres"
POSTGRES_DB="lmsdb"
POSTGRES_USER="lmsuser"

echo "Lesson: $LESSON_ID"
echo "Output: $OUT_NAME"
echo "Using Docker network: $DOCKER_NETWORK"

echo "1) Obtener file_key desde la BD (preferible a usar presigned URL)"
FILE_KEY=$(docker exec -i "$POSTGRES_CONTAINER" psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -t -A -c "SELECT file_key FROM lessons WHERE id=$LESSON_ID;" | tr -d '\r' || true)

if [ -n "$FILE_KEY" ]; then
  echo "Found file_key: $FILE_KEY"
else
  echo "file_key not found in DB, falling back to fileUrl from API"
  FILE_JSON=$(curl -sS "http://localhost:8080/api/lessons/${LESSON_ID}") || { echo "Error: no se pudo obtener /api/lessons/${LESSON_ID}" >&2; exit 2; }
  FILE_URL=$(echo "$FILE_JSON" | grep -o '"fileUrl":"[^"]*"' | sed -E 's/"fileUrl":"([^"]+)"/\1/' | sed 's/\\u002520/%20/g' || true)
  if [ -z "$FILE_URL" ]; then
    echo "No fileUrl found in API response:"
    echo "$FILE_JSON"
    exit 3
  fi
  echo "fileUrl: $FILE_URL"
  echo "Downloading via fileUrl (fallback) to $ORIG_PATH ..."
  curl -L -o "$ORIG_PATH" "$FILE_URL"
fi

# 2) If we have a file_key, download directly from MinIO using mc inside a container on the docker network
if [ -n "$FILE_KEY" ]; then
  echo "2) Descargar objeto desde MinIO usando mc (red: $DOCKER_NETWORK)"
  docker run --rm \
    --network "$DOCKER_NETWORK" \
    -v "$TMP_DIR":/work \
    --entrypoint sh \
    minio/mc:latest -c "mc alias set $MINIO_ALIAS http://$MINIO_HOST_INTERNAL $MINIO_USER $MINIO_PASS && mc cp \"$MINIO_ALIAS/$MINIO_BUCKET/$FILE_KEY\" /work/orig && echo ok" || { echo "Error: mc cp falló" >&2; exit 4; }
  ls -lh "$ORIG_PATH"
fi

# 3) Transcodificar a MP4 usando imagen Docker de ffmpeg
# Usamos imagen 'jrottenberg/ffmpeg' (variantes modernas) para evitar instalar ffmpeg localmente
# Nota: la imagen requerirá acceso al archivo en el host (montamos TMP_DIR)

echo "3) Transcodificando a MP4 con H.264/AAC... (esto puede tardar)"

docker run --rm \
  --network "$DOCKER_NETWORK" \
  -v "$TMP_DIR":/work \
  jrottenberg/ffmpeg:latest \
  -y -i "/work/orig" -c:v libx264 -preset veryfast -crf 23 -c:a aac -b:a 128k "/work/$OUT_NAME"

ls -lh "$OUT_PATH"

# 4) Subir MP4 a MinIO usando mc dentro de un contenedor (se conecta a minio en la red)
# Generamos un nombre único para evitar colisiones
UNIQUE_NAME="videos/$(uuidgen)_${OUT_NAME}"

echo "4) Subiendo $OUT_NAME a MinIO como $UNIQUE_NAME ..."

docker run --rm \
  --network "$DOCKER_NETWORK" \
  -v "$TMP_DIR":/work \
  --entrypoint sh \
  minio/mc:latest -c "mc alias set $MINIO_ALIAS http://$MINIO_HOST_INTERNAL $MINIO_USER $MINIO_PASS && mc cp /work/$OUT_NAME $MINIO_ALIAS/$MINIO_BUCKET/$UNIQUE_NAME && echo 'ok'"

if [ $? -ne 0 ]; then
  echo "Error: la subida a MinIO falló" >&2
  exit 5
fi

echo "Archivo subido a minio://$MINIO_BUCKET/$UNIQUE_NAME"

# 5) Actualizar la fila lessons.file_key en Postgres
echo "5) Actualizando la fila lessons (id=$LESSON_ID) con file_key='$UNIQUE_NAME'"
SQL="UPDATE lessons SET file_key='$UNIQUE_NAME' WHERE id=$LESSON_ID;"

docker exec -i "$POSTGRES_CONTAINER" psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "$SQL"

# 6) Limpiar archivos temporales
# (podemos conservar si quieres)
# rm -rf "$TMP_DIR"

# 7) Mostrar nuevo fileUrl solicitándolo al backend
echo "Hecho. Solicita la lección para ver la nueva fileUrl:"
curl -sS "http://localhost:8080/api/lessons/${LESSON_ID}" | sed -n '1,200p'

echo "Transcodificación y subida completadas. Si el nuevo archivo no reproduce, por favor indica la salida de los comandos anteriores."

exit 0
